// helm-compose2chart-plugin: a simple Helm plugin written in Go
// --------------------------------------------------------
// Single-file prototype: `main.go`.
// Purpose: read a Docker Compose YAML file and generate a Helm chart
// (Chart.yaml, values.yaml, templates/*) suitable for packaging.
//
// Usage (build):
//   go build -o helm-compose2chart
//   # Install as a helm plugin by placing the executable into your helm plugins dir
//   # or use Helm's plugin install procedure (create plugin.yaml etc.).
//
// Example run:
//   ./helm-compose2chart -f docker-compose.yml -o ./mychart -n mychart
//
// Limitations: this is a pragmatic, small converter. It supports basic keys:
//   image, ports, environment, replicas, command, args, labels
// Volumes, networks, build contexts and complex mount setups are not fully
// translated; they will be emitted into comments or the values.yaml for manual
// adjustment.
//
// Dependencies: uses gopkg.in/yaml.v3 only (standard Go tooling).

package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"gopkg.in/yaml.v3"
)

// minimal types to hold compose file
type ComposeFile map[string]interface{}

func main() {
	composePath := flag.String("f", "docker-compose.yml", "path to docker-compose file")
	out := flag.String("o", "./chart", "output directory for generated Helm chart")
	chartName := flag.String("n", "generated-chart", "chart name")
	appVersion := flag.String("app-version", "0.1.0", "Chart appVersion")
	version := flag.String("version", "0.1.0", "Chart version")
	flag.Parse()

	b, err := ioutil.ReadFile(*composePath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error reading compose file: %v\n", err)
		os.Exit(2)
	}

	var compose ComposeFile
	if err := yaml.Unmarshal(b, &compose); err != nil {
		fmt.Fprintf(os.Stderr, "error parsing compose yaml: %v\n", err)
		os.Exit(2)
	}

	servicesRaw, ok := compose["services"]
	if !ok {
		fmt.Fprintln(os.Stderr, "compose file contains no 'services' key")
		os.Exit(2)
	}

	servicesMap, ok := servicesRaw.(map[string]interface{})
	if !ok {
		fmt.Fprintln(os.Stderr, "unexpected type for 'services' in compose file")
		os.Exit(2)
	}

	if err := os.MkdirAll(*out, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "error creating output directory: %v\n", err)
		os.Exit(2)
	}

	// create chart dir structure
	chartDir := *out
	templatesDir := filepath.Join(chartDir, "templates")
	os.MkdirAll(templatesDir, 0755)

	// Chart.yaml
	chartYaml := fmt.Sprintf("apiVersion: v2\nname: %s\nversion: %s\nappVersion: \"%s\"\n", *chartName, *version, *appVersion)
	ioutil.WriteFile(filepath.Join(chartDir, "Chart.yaml"), []byte(chartYaml), 0644)

	// values map to fill values.yaml
	values := map[string]interface{}{"services": map[string]interface{}{}}

	// create templates per service
	for svcName, svcDefRaw := range servicesMap {
		svcDef, _ := svcDefRaw.(map[string]interface{})
		safeName := sanitizeName(svcName)

		svcValues := map[string]interface{}{}

		// image
		if img, ok := svcDef["image"].(string); ok {
			svcValues["image"] = img
		}

		// replicas (optional)
		if repl, ok := svcDef["deploy"].(map[string]interface{}); ok {
			if r, ok := repl["replicas"]; ok {
				svcValues["replicaCount"] = r
			}
		}
		if _, ok := svcValues["replicaCount"]; !ok {
			svcValues["replicaCount"] = 1
		}

		// environment
		if env, ok := svcDef["environment"]; ok {
			svcValues["environment"] = env
		}

		// ports
		if ports, ok := svcDef["ports"]; ok {
			svcValues["ports"] = ports
		}

		// command / entrypoint
		if cmd, ok := svcDef["command"]; ok {
			svcValues["command"] = cmd
		}
		if args, ok := svcDef["args"]; ok {
			svcValues["args"] = args
		}

		// labels
		if labels, ok := svcDef["labels"]; ok {
			svcValues["labels"] = labels
		}

		// volumes (will be included in values for manual handling)
		if vols, ok := svcDef["volumes"]; ok {
			svcValues["volumes"] = vols
		}

		// add to values map
		values["services"].(map[string]interface{})[safeName] = svcValues

		// generate Deployment template
		deployYaml := renderDeploymentTemplate(svcName, safeName)
		ioutil.WriteFile(filepath.Join(templatesDir, safeName+"-deployment.yaml"), []byte(deployYaml), 0644)

		// generate Service template if ports are present
		if _, ok := svcValues["ports"]; ok {
			serviceYaml := renderServiceTemplate(svcName, safeName)
			ioutil.WriteFile(filepath.Join(templatesDir, safeName+"-service.yaml"), []byte(serviceYaml), 0644)
		}
	}

	// write values.yaml
	valBytes, _ := yaml.Marshal(values)
	ioutil.WriteFile(filepath.Join(chartDir, "values.yaml"), valBytes, 0644)

	// NOTES.txt
	notes := "Generated by helm-compose2chart-plugin\nReview values.yaml and templates before deploying.\n"
	ioutil.WriteFile(filepath.Join(chartDir, "templates", "NOTES.txt"), []byte(notes), 0644)

	fmt.Printf("Helm chart generated at %s\n", chartDir)
}

func sanitizeName(s string) string {
	// helm template and filenames: allow alphanum and -
	s := strings.ToLower(s)
	re := regexp.MustCompile(`[^a-z0-9-]`)
	return re.ReplaceAllString(s, "-")
}

func renderDeploymentTemplate(origName, safeName string) string {
	// This template produces a Deployment that references .Values.services.<safeName>
	var t = `apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "{{ .Chart.Name }}-` + safeName + `" . }}
  labels:
    app: ` + safeName + `
spec:
  replicas: {{ .Values.services.` + safeName + `.replicaCount | default 1 }}
  selector:
    matchLabels:
      app: ` + safeName + `
  template:
    metadata:
      labels:
        app: ` + safeName + `
    spec:
      containers:
        - name: ` + safeName + `
          image: {{ .Values.services.` + safeName + `.image }}
          {{- if .Values.services.` + safeName + `.command }}
          command: {{ toYaml .Values.services.` + safeName + `.command | nindent 10 }}
          {{- end }}
          {{- if .Values.services.` + safeName + `.args }}
          args: {{ toYaml .Values.services.` + safeName + `.args | nindent 10 }}
          {{- end }}
          {{- if .Values.services.` + safeName + `.environment }}
          env:
{{ toYaml .Values.services.` + safeName + `.environment | indent 12 }}
          {{- end }}
` + `          ports:
          {{- if .Values.services.` + safeName + `.ports }}
          {{- range $idx, $p := .Values.services.` + safeName + `.ports }}
          - name: port-{{$idx}}
            containerPort: {{ parsePort $p }}
          {{- end }}
          {{- end }}
`
	// Note: parsePort is not a built-in Helm function; users may need to adapt.
	// We'll include a helper in _helpers.tpl to parse common "host:container" forms.
	return t + "\n---\n" + renderHelpersTpl()
}

func renderServiceTemplate(origName, safeName string) string {
	var t = `apiVersion: v1
kind: Service
metadata:
  name: {{ include "{{ .Chart.Name }}-` + safeName + `" . }}
  labels:
    app: ` + safeName + `
spec:
  type: ClusterIP
  selector:
    app: ` + safeName + `
  ports:
  {{- if .Values.services.` + safeName + `.ports }}
  {{- range $idx, $p := .Values.services.` + safeName + `.ports }}
  - port: {{ parsePort $p }}
    targetPort: {{ parsePort $p }}
    name: port-{{$idx}}
  {{- end }}
  {{- end }}
`
	return t
}

func renderHelpersTpl() string {
	// helpers with a parsePort function (simple): will try to extract last number after ':' or the number itself
	helpers := `{{/* Helper template for generated chart */}}
{{- define "{{ .Chart.Name }}-fullname" -}}
{{- printf "%s-%s" .Release.Name .Chart.Name -}}
{{- end -}}

{{- /* parsePort: takes a port string like "8080" or "127.0.0.1:8080" or "80:8080" and returns the container port (last number) */ -}}
{{-/* Note: Helm templates do not support regex; we implement a best-effort using split and last element. */ -}}
{{- define "parsePort" -}}
  {{- $p := . -}}
  {{- $parts := split ":" (printf "%v" $p) -}}
  {{- $last := index $parts (sub (len $parts) 1) -}}
  {{- printf "%s" $last -}}
{{- end -}}
`
	return helpers
}
